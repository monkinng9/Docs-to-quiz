{
    "raw": "---\n\n### **Polished Summary and Study Guide for CrewAI Flows**  \n\n---\n\n### **High-Level Summary**  \nCrewAI Flows is a feature designed to streamline the creation and management of AI workflows. It enables developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Key features include:  \n- **Simplified Workflow Creation**: Easily connect multiple tasks and manage state.  \n- **Event-Driven Architecture**: Create structured, event-driven workflows.  \n- **Flexible Control Flow**: Implement conditional logic and dynamic routing.  \n- **State Management**: Supports both unstructured (dynamic) and structured (type-safe) approaches.  \n- **Visualization Tools**: Generate interactive plots to visualize workflows and optimize design.  \n- **Crew Integration**: Combine multiple Crews into a single Flow for complex multi-step processes.  \n\n---\n\n### **Detailed Summaries**  \n\n#### **1. Introduction**  \nCrewAI Flows simplifies the creation and management of AI workflows by allowing developers to chain together multiple Crews and tasks. Key features include:  \n- Simplified workflow creation.  \n- State management for data sharing between tasks.  \n- Event-driven architecture for structured workflows.  \n- Flexible control flow with conditional logic and routing.  \n\n#### **2. Getting Started**  \nThis section provides a step-by-step guide to creating a simple Flow using OpenAI to:  \n1. Generate a random city.  \n2. Generate a fun fact about that city.  \nThe example demonstrates the use of `@start()` and `@listen()` decorators to define tasks and their dependencies.  \n\n#### **3. @start()**  \nThe `@start()` decorator marks a method as the starting point of a Flow. Multiple start methods can execute in parallel when the Flow is initiated.  \n\n#### **4. @listen()**  \nThe `@listen()` decorator marks a method as a listener for the output of another task. It is triggered when the specified task emits an output, which can be accessed as an argument.  \n\n#### **5. Flow Output**  \nThe final output of a Flow is determined by the last method that completes. It can be retrieved using the `kickoff()` method. The state of the Flow can also be accessed and updated for data sharing between tasks.  \n\n#### **6. Flow State Management**  \nCrewAI Flows supports:  \n- **Unstructured State Management**: Dynamic state attributes for flexibility.  \n- **Structured State Management**: Predefined schemas for type safety and consistency.  \n\n#### **7. Flow Control**  \nConditional logic and routing are implemented using:  \n- `or_` and `and_` functions for conditional execution.  \n- `@router()` decorator for dynamic routing based on method outputs.  \n\n#### **8. Adding Crews to Flows**  \nMultiple Crews can be integrated into a single Flow using the `crewai create flow` command. The `main.py` file defines the Flow and connects the Crews for complex multi-step processes.  \n\n#### **9. Plot Flows**  \nInteractive plots visualize tasks, connections, and data flow. Plots can be generated using the `plot()` method or the command line.  \n\n#### **10. Next Steps**  \nExplore additional examples of Flows, such as:  \n- Email Auto Responder Flow.  \n- Lead Score Flow.  \n- Write a Book Flow.  \n- Meeting Assistant Flow.  \n\n---\n\n### **Study Guide**  \n\n#### **Learning Objectives**  \n1. Understand the core features and benefits of CrewAI Flows.  \n2. Learn how to create and manage AI workflows using Flows.  \n3. Master the use of `@start()` and `@listen()` decorators to define tasks and their dependencies.  \n4. Explore state management options, including unstructured and structured approaches.  \n5. Implement conditional logic and routing in Flows using `or_`, `and_`, and `@router()`.  \n6. Visualize Flows using interactive plots to optimize workflow design.  \n7. Integrate multiple Crews into a single Flow for complex multi-step processes.  \n\n#### **Key Concepts and Definitions**  \n- **Flow**: A structured, event-driven workflow that connects multiple tasks and manages state.  \n- **@start()**: A decorator that marks a method as the starting point of a Flow.  \n- **@listen()**: A decorator that marks a method as a listener for the output of another task.  \n- **State Management**: The process of managing and sharing data between tasks in a Flow.  \n- **Unstructured State Management**: A flexible approach that allows dynamic state attributes.  \n- **Structured State Management**: A type-safe approach using predefined schemas.  \n- **Conditional Logic**: Control flow mechanisms like `or_`, `and_`, and `@router()` for dynamic execution.  \n- **Plot**: A graphical representation of a Flow that visualizes tasks, connections, and data flow.  \n\n#### **Review Questions**  \n1. What are the key features of CrewAI Flows?  \n2. How do you define the starting point of a Flow?  \n3. What is the purpose of the `@listen()` decorator?  \n4. What are the differences between unstructured and structured state management?  \n5. How can you implement conditional logic in a Flow?  \n6. What is the purpose of visualizing a Flow using plots?  \n7. How do you integrate multiple Crews into a single Flow?  \n\n#### **Practice Exercises and Discussion Points**  \n1. Create a simple Flow that generates a random number and then calculates its square.  \n2. Modify the example Flow to include a third task that logs the output of the first two tasks.  \n3. Implement a Flow that uses structured state management to track the number of times a task is executed.  \n4. Design a Flow with conditional logic that routes execution based on the output of a task.  \n5. Generate a plot of a Flow and analyze its structure to identify potential bottlenecks.  \n\n#### **Important Terms and Concepts to Remember**  \n- Flow  \n- @start()  \n- @listen()  \n- State Management  \n- Unstructured State  \n- Structured State  \n- Conditional Logic  \n- Plot  \n\n---\n\nThis polished summary and study guide is structured for effective learning and retention, with clear organization, bullet points, and numbered lists to enhance readability. It integrates the summaries and study guide components seamlessly, ensuring a comprehensive learning experience.",
    "pydantic": "None",
    "json_dict": "None",
    "tasks_output": [
        {
            "description": "Your task is to extract key information from the following document:\n\n\n# Flows\n\n## Introduction\nCrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows. Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations.\nFlows allow you to create structured, event-driven workflows. They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications. With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI\u2019s capabilities.\n  1. **Simplified Workflow Creation** : Easily chain together multiple Crews and tasks to create complex AI workflows.\n  2. **State Management** : Flows make it super easy to manage and share state between different tasks in your workflow.\n  3. **Event-Driven Architecture** : Built on an event-driven model, allowing for dynamic and responsive workflows.\n  4. **Flexible Control Flow** : Implement conditional logic, loops, and branching within your workflows.\n\n\n## Getting Started\nLet\u2019s create a simple Flow where you will use OpenAI to generate a random city in one task and then use that city to generate a fun fact in another task.\n\n```python\n\nfrom crewai.flow.flow import Flow, listen, start\nfrom dotenv import load_dotenv\nfrom litellm import completion\n\n\nclass ExampleFlow(Flow):\n    model = \"gpt-4o-mini\"\n\n    @start()\n    def generate_city(self):\n        print(\"Starting flow\")\n\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Return the name of a random city in the world.\",\n                },\n            ],\n        )\n\n        random_city = response[\"choices\"][0][\"message\"][\"content\"]\n        print(f\"Random City: {random_city}\")\n\n        return random_city\n\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n        response = completion(\n            model=self.model,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Tell me a fun fact about {random_city}\",\n                },\n            ],\n        )\n\n        fun_fact = response[\"choices\"][0][\"message\"][\"content\"]\n        return fun_fact\n\n\n\nflow = ExampleFlow()\nresult = flow.kickoff()\n\nprint(f\"Generated fun fact: {result}\")\n```\n\nIn the above example, we have created a simple Flow that generates a random city using OpenAI and then generates a fun fact about that city. The Flow consists of two tasks: `generate_city` and `generate_fun_fact`. The `generate_city` task is the starting point of the Flow, and the `generate_fun_fact` task listens for the output of the `generate_city` task.\nWhen you run the Flow, it will generate a random city and then generate a fun fact about that city. The output will be printed to the console.\n**Note:** Ensure you have set up your `.env` file to store your `OPENAI_API_KEY`. This key is necessary for authenticating requests to the OpenAI API.\n\n### @start()\nThe `@start()` decorator is used to mark a method as the starting point of a Flow. When a Flow is started, all the methods decorated with `@start()` are executed in parallel. You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.\n### @listen()\n\nThe `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow. The method decorated with `@listen()` will be executed when the specified task emits an output. The method can access the output of the task it is listening to as an argument.\n\n#### Usage\nThe `@listen()` decorator can be used in several ways:\n  1. **Listening to a Method by Name** : You can pass the name of the method you want to listen to as a string. When that method completes, the listener method will be triggered.\n    ```python\n    @listen(\"generate_city\")\n    def generate_fun_fact(self, random_city):\n    # Implementation\n\n    ```\n\n  2. **Listening to a Method Directly** : You can pass the method itself. When that method completes, the listener method will be triggered.\n    ```python\n    @listen(generate_city)\n    def generate_fun_fact(self, random_city):\n    # Implementation\n\n    ```\n\n### Flow Output\nAccessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems. CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.\n\n#### Retrieving the Final Output\nWhen you run a Flow, the final output is determined by the last method that completes. The `kickoff()` method returns the output of this final method.\nHere\u2019s how you can access the final output:\n```python\nfrom crewai.flow.flow import Flow, listen, start\nclass OutputExampleFlow(Flow):\n  @start()\n  def first_method(self):\n    return \"Output from first_method\"\n  @listen(first_method)\n  def second_method(self, first_output):\n    return f\"Second method received: {first_output}\"\n\nflow = OutputExampleFlow()\nfinal_output = flow.kickoff()\nprint(\"---- Final Output ----\")\nprint(final_output)\n```\n\nIn this example, the `second_method` is the last method to complete, so its output will be the final output of the Flow. The `kickoff()` method will return the final output, which is then printed to the console.\n\n#### Accessing and Updating State\nIn addition to retrieving the final output, you can also access and update the state within your Flow. The state can be used to store and share data between different methods in the Flow. After the Flow has run, you can access the state to retrieve any information that was added or updated during the execution.\n\nHere\u2019s an example of how to update and access the state:\n\n```python\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\nclass ExampleState(BaseModel):\n  counter: int = 0\n  message: str = \"\"\nclass StateExampleFlow(Flow[ExampleState]):\n  @start()\n  def first_method(self):\n    self.state.message = \"Hello from first_method\"\n    self.state.counter += 1\n  @listen(first_method)\n  def second_method(self):\n    self.state.message += \" - updated by second_method\"\n    self.state.counter += 1\n    return self.state.message\nflow = StateExampleFlow()\nfinal_output = flow.kickoff()\nprint(f\"Final Output: {final_output}\")\nprint(\"Final State:\")\nprint(flow.state)\n```\n\nIn this example, the state is updated by both `first_method` and `second_method`. After the Flow has run, you can access the final state to see the updates made by these methods.\nBy ensuring that the final method\u2019s output is returned and providing access to the state, CrewAI Flows make it easy to integrate the results of your AI workflows into larger applications or systems, while also maintaining and accessing the state throughout the Flow\u2019s execution.\n\n## Flow State Management\nManaging state effectively is crucial for building reliable and maintainable AI workflows. CrewAI Flows provides robust mechanisms for both unstructured and structured state management, allowing developers to choose the approach that best fits their application\u2019s needs.\n\n### Unstructured State Management\nIn unstructured state management, all state is stored in the `state` attribute of the `Flow` class. This approach offers flexibility, enabling developers to add or modify state attributes on the fly without defining a strict schema.\n\n```python\nfrom crewai.flow.flow import Flow, listen, start\nclass UntructuredExampleFlow(Flow):\n  @start()\n  def first_method(self):\n    self.state.message = \"Hello from structured flow\"\n    self.state.counter = 0\n  @listen(first_method)\n  def second_method(self):\n    self.state.counter += 1\n    self.state.message += \" - updated\"\n  @listen(second_method)\n  def third_method(self):\n    self.state.counter += 1\n    self.state.message += \" - updated again\"\n    print(f\"State after third_method: {self.state}\")\n\nflow = UntructuredExampleFlow()\nflow.kickoff()\n```\n\n**Key Points:**\n  * **Flexibility:** You can dynamically add attributes to `self.state` without predefined constraints.\n  * **Simplicity:** Ideal for straightforward workflows where state structure is minimal or varies significantly.\n\n### Structured State Management\nStructured state management leverages predefined schemas to ensure consistency and type safety across the workflow. By using models like Pydantic\u2019s `BaseModel`, developers can define the exact shape of the state, enabling better validation and auto-completion in development environments.\n\n```python\nfrom crewai.flow.flow import Flow, listen, start\nfrom pydantic import BaseModel\n\nclass ExampleState(BaseModel):\n  counter: int = 0\n  message: str = \"\"\n\nclass StructuredExampleFlow(Flow[ExampleState]):\n  @start()\n  def first_method(self):\n    self.state.message = \"Hello from structured flow\"\n  @listen(first_method)\n  def second_method(self):\n    self.state.counter += 1\n    self.state.message += \" - updated\"\n  @listen(second_method)\n  def third_method(self):\n    self.state.counter += 1\n    self.state.message += \" - updated again\"\n    print(f\"State after third_method: {self.state}\")\n\nflow = StructuredExampleFlow()\nflow.kickoff()\n\n```\n\n**Key Points:**\n  * **Defined Schema:** `ExampleState` clearly outlines the state structure, enhancing code readability and maintainability.\n  * **Type Safety:** Leveraging Pydantic ensures that state attributes adhere to the specified types, reducing runtime errors.\n  * **Auto-Completion:** IDEs can provide better auto-completion and error checking based on the defined state model.\n\n\n### Choosing Between Unstructured and Structured State Management\n  * **Use Unstructured State Management when:**\n    * The workflow\u2019s state is simple or highly dynamic.\n    * Flexibility is prioritized over strict state definitions.\n    * Rapid prototyping is required without the overhead of defining schemas.\n  * **Use Structured State Management when:**\n    * The workflow requires a well-defined and consistent state structure.\n    * Type safety and validation are important for your application\u2019s reliability.\n    * You want to leverage IDE features like auto-completion and type checking for better developer experience.\n\n\nBy providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.\n\n## Flow Control\n\n### Conditional Logic: `or`\nThe `or_` function in Flows allows you to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.\n\n```python\nfrom crewai.flow.flow import Flow, listen, or_, start\nclass OrExampleFlow(Flow):\n  @start()\n  def start_method(self):\n    return \"Hello from the start method\"\n  @listen(start_method)\n  def second_method(self):\n    return \"Hello from the second method\"\n  @listen(or_(start_method, second_method))\n  def logger(self, result):\n    print(f\"Logger: {result}\")\n\nflow = OrExampleFlow()\nflow.kickoff()\n```\n\nWhen you run this Flow, the `logger` method will be triggered by the output of either the `start_method` or the `second_method`. The `or_` function is used to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.\n\n### Conditional Logic: `and`\nThe `and_` function in Flows allows you to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.\n\n```python\nfrom crewai.flow.flow import Flow, and_, listen, start\nclass AndExampleFlow(Flow):\n  @start()\n  def start_method(self):\n    self.state[\"greeting\"] = \"Hello from the start method\"\n  @listen(start_method)\n  def second_method(self):\n    self.state[\"joke\"] = \"What do computers eat? Microchips.\"\n  @listen(and_(start_method, second_method))\n  def logger(self):\n    print(\"---- Logger ----\")\n    print(self.state)\nflow = AndExampleFlow()\nflow.kickoff()\n```\n\nWhen you run this Flow, the `logger` method will be triggered only when both the `start_method` and the `second_method` emit an output. The `and_` function is used to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.\n### Router\nThe `@router()` decorator in Flows allows you to define conditional routing logic based on the output of a method. You can specify different routes based on the output of the method, allowing you to control the flow of execution dynamically.\n\n\n```python\nimport random\nfrom crewai.flow.flow import Flow, listen, router, start\nfrom pydantic import BaseModel\nclass ExampleState(BaseModel):\n  success_flag: bool = False\nclass RouterFlow(Flow[ExampleState]):\n  @start()\n  def start_method(self):\n    print(\"Starting the structured flow\")\n    random_boolean = random.choice([True, False])\n    self.state.success_flag = random_boolean\n  @router(start_method)\n  def second_method(self):\n    if self.state.success_flag:\n      return \"success\"\n    else:\n      return \"failed\"\n  @listen(\"success\")\n  def third_method(self):\n    print(\"Third method running\")\n  @listen(\"failed\")\n  def fourth_method(self):\n    print(\"Fourth method running\")\n\nflow = RouterFlow()\nflow.kickoff()\n\n```\n\nIn the above example, the `start_method` generates a random boolean value and sets it in the state. The `second_method` uses the `@router()` decorator to define conditional routing logic based on the value of the boolean. If the boolean is `True`, the method returns `\"success\"`, and if it is `False`, the method returns `\"failed\"`. The `third_method` and `fourth_method` listen to the output of the `second_method` and execute based on the returned value.\nWhen you run this Flow, the output will change based on the random boolean value generated by the `start_method`.\n\n## Adding Crews to Flows\nCreating a flow with multiple crews in CrewAI is straightforward.\nYou can generate a new CrewAI project that includes all the scaffolding needed to create a flow with multiple crews by running the following command:\n\n```bash\ncrewai create flow name_of_flow\n```\n\nThis command will generate a new CrewAI project with the necessary folder structure. The generated project includes a prebuilt crew called `poem_crew` that is already working. You can use this crew as a template by copying, pasting, and editing it to create other crews.\n\n### Folder Structure\nAfter running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following:\nDirectory/File| Description  \n---|---  \n`name_of_flow/`| Root directory for the flow.  \n\u251c\u2500\u2500 `crews/`| Contains directories for specific crews.  \n\u2502 \u2514\u2500\u2500 `poem_crew/`| Directory for the \u201cpoem_crew\u201d with its configurations and scripts.  \n\u2502 \u251c\u2500\u2500 `config/`| Configuration files directory for the \u201cpoem_crew\u201d.  \n\u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`| YAML file defining the agents for \u201cpoem_crew\u201d.  \n\u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`| YAML file defining the tasks for \u201cpoem_crew\u201d.  \n\u2502 \u251c\u2500\u2500 `poem_crew.py`| Script for \u201cpoem_crew\u201d functionality.  \n\u251c\u2500\u2500 `tools/`| Directory for additional tools used in the flow.  \n\u2502 \u2514\u2500\u2500 `custom_tool.py`| Custom tool implementation.  \n\u251c\u2500\u2500 `main.py`| Main script for running the flow.  \n\u251c\u2500\u2500 `README.md`| Project description and instructions.  \n\u251c\u2500\u2500 `pyproject.toml`| Configuration file for project dependencies and settings.  \n\u2514\u2500\u2500 `.gitignore`| Specifies files and directories to ignore in version control.  \n\n### Building Your Crews\nIn the `crews` folder, you can define multiple crews. Each crew will have its own folder containing configuration files and the crew definition file. For example, the `poem_crew` folder contains:\n  * `config/agents.yaml`: Defines the agents for the crew.\n  * `config/tasks.yaml`: Defines the tasks for the crew.\n  * `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself.\n\nYou can copy, paste, and edit the `poem_crew` to create other crews.\n\n### Connecting Crews in `main.py`\nThe `main.py` file is where you create your flow and connect the crews together. You can define your flow by using the `Flow` class and the decorators `@start` and `@listen` to specify the flow of execution.\nHere\u2019s an example of how you can connect the `poem_crew` in the `main.py` file:\n\n```python\n#!/usr/bin/env python\nfrom random import randint\nfrom pydantic import BaseModel\nfrom crewai.flow.flow import Flow, listen, start\nfrom .crews.poem_crew.poem_crew import PoemCrew\nclass PoemState(BaseModel):\n  sentence_count: int = 1\n  poem: str = \"\"\nclass PoemFlow(Flow[PoemState]):\n  @start()\n  def generate_sentence_count(self):\n    print(\"Generating sentence count\")\n    self.state.sentence_count = randint(1, 5)\n  @listen(generate_sentence_count)\n  def generate_poem(self):\n    print(\"Generating poem\")\n    result = PoemCrew().crew().kickoff(inputs={\"sentence_count\": self.state.sentence_count})\n    print(\"Poem generated\", result.raw)\n    self.state.poem = result.raw\n  @listen(generate_poem)\n  def save_poem(self):\n    print(\"Saving poem\")\n    with open(\"poem.txt\", \"w\") as f:\n      f.write(self.state.poem)\ndef kickoff():\n  poem_flow = PoemFlow()\n  poem_flow.kickoff()\n\ndef plot():\n  poem_flow = PoemFlow()\n  poem_flow.plot()\nif __name__ == \"__main__\":\n  kickoff()\n\n```\n\nIn this example, the `PoemFlow` class defines a flow that generates a sentence count, uses the `PoemCrew` to generate a poem, and then saves the poem to a file. The flow is kicked off by calling the `kickoff()` method.\n\n### Running the Flow\n(Optional) Before running the flow, you can install the dependencies by running:\n\n```bash\ncrewai install\n```\n\nOnce all of the dependencies are installed, you need to activate the virtual environment by running:\n```bash\nsource .venv/bin/activate\n```\n\nAfter activating the virtual environment, you can run the flow by executing one of the following commands:\n```bash\ncrewai flow kickoff\n```\n\nor\n\n```bash\nuv run kickoff\n\n```\n\nThe flow will execute, and you should see the output in the console.\n\n## Plot Flows\nVisualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows. CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.\n\n### What are Plots?\nPlots in CrewAI are graphical representations of your AI workflows. They display the various tasks, their connections, and the flow of data between them. This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations.\n### How to Generate a Plot\n\nCrewAI provides two convenient methods to generate plots of your flows:\n#### Option 1: Using the `plot()` Method\nIf you are working directly with a flow instance, you can generate a plot by calling the `plot()` method on your flow object. This method will create an HTML file containing the interactive plot of your flow.\n\n```python\n# Assuming you have a flow instance\nflow.plot(\"my_flow_plot\")\n\n```\n\nThis will generate a file named `my_flow_plot.html` in your current directory. You can open this file in a web browser to view the interactive plot.\n#### Option 2: Using the Command Line\nIf you are working within a structured CrewAI project, you can generate a plot using the command line. This is particularly useful for larger projects where you want to visualize the entire flow setup.\n\n```bash\ncrewai flow plot\n```\n\nThis command will generate an HTML file with the plot of your flow, similar to the `plot()` method. The file will be saved in your project directory, and you can open it in a web browser to explore the flow.\n\n### Understanding the Plot\nThe generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution. The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details.\nBy visualizing your flows, you can gain a clearer understanding of the workflow\u2019s structure, making it easier to debug, optimize, and communicate your AI processes to others.\n\n### Conclusion\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows. Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation.\n\n## Next Steps\nIf you\u2019re interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository. Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example:\n  1. **Email Auto Responder Flow** : This example demonstrates an infinite loop where a background job continually runs to automate email responses. It\u2019s a great use case for tasks that need to be performed repeatedly without manual intervention. View Example\n  2. **Lead Score Flow** : This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It\u2019s an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. View Example\n  3. **Write a Book Flow** : This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. View Example\n  4. **Meeting Assistant Flow** : This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It\u2019s a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. View Example\n\nPlease extract key concepts, arguments, evidence, data, and important quotes. Pay attention to headings and subheadings to guide your extraction. Organize the information by sections as they appear in the document.",
            "name": "None",
            "expected_output": "A dictionary containing extracted information categorized by sections. Each key should represent a section title and the value should be a list of extracted data points (text or quotes) related to that section.",
            "summary": "Your task is to extract key information from the following...",
            "raw": "```python\n{\n    \"Introduction\": [\n        \"CrewAI Flows is a powerful feature designed to streamline the creation and management of AI workflows.\",\n        \"Flows allow developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations.\",\n        \"Flows allow you to create structured, event-driven workflows.\",\n        \"They provide a seamless way to connect multiple tasks, manage state, and control the flow of execution in your AI applications.\",\n        \"With Flows, you can easily design and implement multi-step processes that leverage the full potential of CrewAI\u2019s capabilities.\",\n        \"1. **Simplified Workflow Creation** : Easily chain together multiple Crews and tasks to create complex AI workflows.\",\n        \"2. **State Management** : Flows make it super easy to manage and share state between different tasks in your workflow.\",\n        \"3. **Event-Driven Architecture** : Built on an event-driven model, allowing for dynamic and responsive workflows.\",\n        \"4. **Flexible Control Flow** : Implement conditional logic, loops, and branching within your workflows.\"\n    ],\n    \"Getting Started\": [\n        \"Let\u2019s create a simple Flow where you will use OpenAI to generate a random city in one task and then use that city to generate a fun fact in another task.\",\n        \"```python\\nfrom crewai.flow.flow import Flow, listen, start\\nfrom dotenv import load_dotenv\\nfrom litellm import completion\\n\\n\\nclass ExampleFlow(Flow):\\n    model = \\\"gpt-4o-mini\\\"\\n\\n    @start()\\n    def generate_city(self):\\n        print(\\\"Starting flow\\\")\\n\\n        response = completion(\\n            model=self.model,\\n            messages=[\\n                {\\n                    \\\"role\\\": \\\"user\\\",\\n                    \\\"content\\\": \\\"Return the name of a random city in the world.\\\",\\n                },\\n            ],\\n        )\\n\\n        random_city = response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"]\\n        print(f\\\"Random City: {random_city}\\\")\\n\\n        return random_city\\n\\n    @listen(generate_city)\\n    def generate_fun_fact(self, random_city):\\n        response = completion(\\n            model=self.model,\\n            messages=[\\n                {\\n                    \\\"role\\\": \\\"user\\\",\\n                    \\\"content\\\": f\\\"Tell me a fun fact about {random_city}\\\",\\n                },\\n            ],\\n        )\\n\\n        fun_fact = response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"]\\n        return fun_fact\\n\\n\\n\\nflow = ExampleFlow()\\nresult = flow.kickoff()\\n\\nprint(f\\\"Generated fun fact: {result}\\\")\\n```\",\n        \"In the above example, we have created a simple Flow that generates a random city using OpenAI and then generates a fun fact about that city.\",\n        \"The Flow consists of two tasks: `generate_city` and `generate_fun_fact`.\",\n        \"The `generate_city` task is the starting point of the Flow, and the `generate_fun_fact` task listens for the output of the `generate_city` task.\",\n        \"When you run the Flow, it will generate a random city and then generate a fun fact about that city.\",\n        \"The output will be printed to the console.\",\n        \"**Note:** Ensure you have set up your `.env` file to store your `OPENAI_API_KEY`. This key is necessary for authenticating requests to the OpenAI API.\"\n    ],\n    \"@start()\": [\n        \"The `@start()` decorator is used to mark a method as the starting point of a Flow.\",\n        \"When a Flow is started, all the methods decorated with `@start()` are executed in parallel.\",\n        \"You can have multiple start methods in a Flow, and they will all be executed when the Flow is started.\"\n    ],\n    \"@listen()\": [\n        \"The `@listen()` decorator is used to mark a method as a listener for the output of another task in the Flow.\",\n        \"The method decorated with `@listen()` will be executed when the specified task emits an output.\",\n        \"The method can access the output of the task it is listening to as an argument.\",\n        \"#### Usage\\nThe `@listen()` decorator can be used in several ways:\\n  1. **Listening to a Method by Name** : You can pass the name of the method you want to listen to as a string. When that method completes, the listener method will be triggered.\\n    ```python\\n    @listen(\\\"generate_city\\\")\\n    def generate_fun_fact(self, random_city):\\n    # Implementation\\n\\n    ```\\n\\n  2. **Listening to a Method Directly** : You can pass the method itself. When that method completes, the listener method will be triggered.\\n    ```python\\n    @listen(generate_city)\\n    def generate_fun_fact(self, random_city):\\n    # Implementation\\n\\n    ```\"\n    ],\n    \"Flow Output\": [\n        \"Accessing and handling the output of a Flow is essential for integrating your AI workflows into larger applications or systems.\",\n        \"CrewAI Flows provide straightforward mechanisms to retrieve the final output, access intermediate results, and manage the overall state of your Flow.\",\n        \"#### Retrieving the Final Output\\nWhen you run a Flow, the final output is determined by the last method that completes.\",\n        \"The `kickoff()` method returns the output of this final method.\",\n        \"Here\u2019s how you can access the final output:\\n```python\\nfrom crewai.flow.flow import Flow, listen, start\\nclass OutputExampleFlow(Flow):\\n  @start()\\n  def first_method(self):\\n    return \\\"Output from first_method\\\"\\n  @listen(first_method)\\n  def second_method(self, first_output):\\n    return f\\\"Second method received: {first_output}\\\"\\n\\nflow = OutputExampleFlow()\\nfinal_output = flow.kickoff()\\nprint(\\\"---- Final Output ----\\\")\\nprint(final_output)\\n```\",\n        \"In this example, the `second_method` is the last method to complete, so its output will be the final output of the Flow.\",\n        \"The `kickoff()` method will return the final output, which is then printed to the console.\",\n        \"#### Accessing and Updating State\\nIn addition to retrieving the final output, you can also access and update the state within your Flow.\",\n        \"The state can be used to store and share data between different methods in the Flow.\",\n        \"After the Flow has run, you can access the state to retrieve any information that was added or updated during the execution.\",\n        \"Here\u2019s an example of how to update and access the state:\\n```python\\nfrom crewai.flow.flow import Flow, listen, start\\nfrom pydantic import BaseModel\\nclass ExampleState(BaseModel):\\n  counter: int = 0\\n  message: str = \\\"\\\"\\nclass StateExampleFlow(Flow[ExampleState]):\\n  @start()\\n  def first_method(self):\\n    self.state.message = \\\"Hello from first_method\\\"\\n    self.state.counter += 1\\n  @listen(first_method)\\n  def second_method(self):\\n    self.state.message += \\\" - updated by second_method\\\"\\n    self.state.counter += 1\\n    return self.state.message\\nflow = StateExampleFlow()\\nfinal_output = flow.kickoff()\\nprint(f\\\"Final Output: {final_output}\\\")\\nprint(\\\"Final State:\\\")\\nprint(flow.state)\\n```\",\n        \"In this example, the state is updated by both `first_method` and `second_method`.\",\n        \"After the Flow has run, you can access the final state to see the updates made by these methods.\",\n        \"By ensuring that the final method\u2019s output is returned and providing access to the state, CrewAI Flows make it easy to integrate the results of your AI workflows into larger applications or systems, while also maintaining and accessing the state throughout the Flow\u2019s execution.\"\n    ],\n    \"Flow State Management\": [\n        \"Managing state effectively is crucial for building reliable and maintainable AI workflows.\",\n        \"CrewAI Flows provides robust mechanisms for both unstructured and structured state management, allowing developers to choose the approach that best fits their application\u2019s needs.\",\n        \"### Unstructured State Management\\nIn unstructured state management, all state is stored in the `state` attribute of the `Flow` class.\",\n        \"This approach offers flexibility, enabling developers to add or modify state attributes on the fly without defining a strict schema.\",\n        \"```python\\nfrom crewai.flow.flow import Flow, listen, start\\nclass UntructuredExampleFlow(Flow):\\n  @start()\\n  def first_method(self):\\n    self.state.message = \\\"Hello from structured flow\\\"\\n    self.state.counter = 0\\n  @listen(first_method)\\n  def second_method(self):\\n    self.state.counter += 1\\n    self.state.message += \\\" - updated\\\"\\n  @listen(second_method)\\n  def third_method(self):\\n    self.state.counter += 1\\n    self.state.message += \\\" - updated again\\\"\\n    print(f\\\"State after third_method: {self.state}\\\")\\n\\nflow = UntructuredExampleFlow()\\nflow.kickoff()\\n```\",\n        \"**Key Points:**\\n  * **Flexibility:** You can dynamically add attributes to `self.state` without predefined constraints.\\n  * **Simplicity:** Ideal for straightforward workflows where state structure is minimal or varies significantly.\",\n        \"### Structured State Management\\nStructured state management leverages predefined schemas to ensure consistency and type safety across the workflow.\",\n        \"By using models like Pydantic\u2019s `BaseModel`, developers can define the exact shape of the state, enabling better validation and auto-completion in development environments.\",\n        \"```python\\nfrom crewai.flow.flow import Flow, listen, start\\nfrom pydantic import BaseModel\\n\\nclass ExampleState(BaseModel):\\n  counter: int = 0\\n  message: str = \\\"\\\"\\n\\nclass StructuredExampleFlow(Flow[ExampleState]):\\n  @start()\\n  def first_method(self):\\n    self.state.message = \\\"Hello from structured flow\\\"\\n  @listen(first_method)\\n  def second_method(self):\\n    self.state.counter += 1\\n    self.state.message += \\\" - updated\\\"\\n  @listen(second_method)\\n  def third_method(self):\\n    self.state.counter += 1\\n    self.state.message += \\\" - updated again\\\"\\n    print(f\\\"State after third_method: {self.state}\\\")\\n\\nflow = StructuredExampleFlow()\\nflow.kickoff()\\n\\n```\",\n        \"**Key Points:**\\n  * **Defined Schema:** `ExampleState` clearly outlines the state structure, enhancing code readability and maintainability.\\n  * **Type Safety:** Leveraging Pydantic ensures that state attributes adhere to the specified types, reducing runtime errors.\\n  * **Auto-Completion:** IDEs can provide better auto-completion and error checking based on the defined state model.\",\n        \"### Choosing Between Unstructured and Structured State Management\\n  * **Use Unstructured State Management when:**\\n    * The workflow\u2019s state is simple or highly dynamic.\\n    * Flexibility is prioritized over strict state definitions.\\n    * Rapid prototyping is required without the overhead of defining schemas.\\n  * **Use Structured State Management when:**\\n    * The workflow requires a well-defined and consistent state structure.\\n    * Type safety and validation are important for your application\u2019s reliability.\\n    * You want to leverage IDE features like auto-completion and type checking for better developer experience.\",\n        \"By providing both unstructured and structured state management options, CrewAI Flows empowers developers to build AI workflows that are both flexible and robust, catering to a wide range of application requirements.\"\n    ],\n    \"Flow Control\": [\n        \"### Conditional Logic: `or`\\nThe `or_` function in Flows allows you to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.\",\n        \"```python\\nfrom crewai.flow.flow import Flow, listen, or_, start\\nclass OrExampleFlow(Flow):\\n  @start()\\n  def start_method(self):\\n    return \\\"Hello from the start method\\\"\\n  @listen(start_method)\\n  def second_method(self):\\n    return \\\"Hello from the second method\\\"\\n  @listen(or_(start_method, second_method))\\n  def logger(self, result):\\n    print(f\\\"Logger: {result}\\\")\\n\\nflow = OrExampleFlow()\\nflow.kickoff()\\n```\",\n        \"When you run this Flow, the `logger` method will be triggered by the output of either the `start_method` or the `second_method`.\",\n        \"The `or_` function is used to listen to multiple methods and trigger the listener method when any of the specified methods emit an output.\",\n        \"### Conditional Logic: `and`\\nThe `and_` function in Flows allows you to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.\",\n        \"```python\\nfrom crewai.flow.flow import Flow, and_, listen, start\\nclass AndExampleFlow(Flow):\\n  @start()\\n  def start_method(self):\\n    self.state[\\\"greeting\\\"] = \\\"Hello from the start method\\\"\\n  @listen(start_method)\\n  def second_method(self):\\n    self.state[\\\"joke\\\"] = \\\"What do computers eat? Microchips.\\\"\\n  @listen(and_(start_method, second_method))\\n  def logger(self):\\n    print(\\\"---- Logger ----\\\")\\n    print(self.state)\\nflow = AndExampleFlow()\\nflow.kickoff()\\n```\",\n        \"When you run this Flow, the `logger` method will be triggered only when both the `start_method` and the `second_method` emit an output.\",\n        \"The `and_` function is used to listen to multiple methods and trigger the listener method only when all the specified methods emit an output.\",\n        \"### Router\\nThe `@router()` decorator in Flows allows you to define conditional routing logic based on the output of a method.\",\n        \"You can specify different routes based on the output of the method, allowing you to control the flow of execution dynamically.\",\n        \"```python\\nimport random\\nfrom crewai.flow.flow import Flow, listen, router, start\\nfrom pydantic import BaseModel\\nclass ExampleState(BaseModel):\\n  success_flag: bool = False\\nclass RouterFlow(Flow[ExampleState]):\\n  @start()\\n  def start_method(self):\\n    print(\\\"Starting the structured flow\\\")\\n    random_boolean = random.choice([True, False])\\n    self.state.success_flag = random_boolean\\n  @router(start_method)\\n  def second_method(self):\\n    if self.state.success_flag:\\n      return \\\"success\\\"\\n    else:\\n      return \\\"failed\\\"\\n  @listen(\\\"success\\\")\\n  def third_method(self):\\n    print(\\\"Third method running\\\")\\n  @listen(\\\"failed\\\")\\n  def fourth_method(self):\\n    print(\\\"Fourth method running\\\")\\n\\nflow = RouterFlow()\\nflow.kickoff()\\n\\n```\",\n        \"In the above example, the `start_method` generates a random boolean value and sets it in the state.\",\n        \"The `second_method` uses the `@router()` decorator to define conditional routing logic based on the value of the boolean.\",\n        \"If the boolean is `True`, the method returns `\\\"success\\\"`, and if it is `False`, the method returns `\\\"failed\\\"`.\",\n        \"The `third_method` and `fourth_method` listen to the output of the `second_method` and execute based on the returned value.\",\n        \"When you run this Flow, the output will change based on the random boolean value generated by the `start_method`.\"\n    ],\n    \"Adding Crews to Flows\": [\n        \"Creating a flow with multiple crews in CrewAI is straightforward.\",\n        \"You can generate a new CrewAI project that includes all the scaffolding needed to create a flow with multiple crews by running the following command:\\n```bash\\ncrewai create flow name_of_flow\\n```\",\n        \"This command will generate a new CrewAI project with the necessary folder structure.\",\n        \"The generated project includes a prebuilt crew called `poem_crew` that is already working.\",\n        \"You can use this crew as a template by copying, pasting, and editing it to create other crews.\",\n        \"### Folder Structure\\nAfter running the `crewai create flow name_of_flow` command, you will see a folder structure similar to the following:\\nDirectory/File| Description  \\n---|---  \\n`name_of_flow/`| Root directory for the flow.  \\n\u251c\u2500\u2500 `crews/`| Contains directories for specific crews.  \\n\u2502 \u2514\u2500\u2500 `poem_crew/`| Directory for the \u201cpoem_crew\u201d with its configurations and scripts.  \\n\u2502 \u251c\u2500\u2500 `config/`| Configuration files directory for the \u201cpoem_crew\u201d.  \\n\u2502 \u2502 \u251c\u2500\u2500 `agents.yaml`| YAML file defining the agents for \u201cpoem_crew\u201d.  \\n\u2502 \u2502 \u2514\u2500\u2500 `tasks.yaml`| YAML file defining the tasks for \u201cpoem_crew\u201d.  \\n\u2502 \u251c\u2500\u2500 `poem_crew.py`| Script for \u201cpoem_crew\u201d functionality.  \\n\u251c\u2500\u2500 `tools/`| Directory for additional tools used in the flow.  \\n\u2502 \u2514\u2500\u2500 `custom_tool.py`| Custom tool implementation.  \\n\u251c\u2500\u2500 `main.py`| Main script for running the flow.  \\n\u251c\u2500\u2500 `README.md`| Project description and instructions.  \\n\u251c\u2500\u2500 `pyproject.toml`| Configuration file for project dependencies and settings.  \\n\u2514\u2500\u2500 `.gitignore`| Specifies files and directories to ignore in version control.  \",\n        \"### Building Your Crews\\nIn the `crews` folder, you can define multiple crews.\",\n        \"Each crew will have its own folder containing configuration files and the crew definition file.\",\n        \"For example, the `poem_crew` folder contains:\\n  * `config/agents.yaml`: Defines the agents for the crew.\\n  * `config/tasks.yaml`: Defines the tasks for the crew.\\n  * `poem_crew.py`: Contains the crew definition, including agents, tasks, and the crew itself.\",\n        \"You can copy, paste, and edit the `poem_crew` to create other crews.\",\n        \"### Connecting Crews in `main.py`\\nThe `main.py` file is where you create your flow and connect the crews together.\",\n        \"You can define your flow by using the `Flow` class and the decorators `@start` and `@listen` to specify the flow of execution.\",\n        \"Here\u2019s an example of how you can connect the `poem_crew` in the `main.py` file:\\n```python\\n#!/usr/bin/env python\\nfrom random import randint\\nfrom pydantic import BaseModel\\nfrom crewai.flow.flow import Flow, listen, start\\nfrom .crews.poem_crew.poem_crew import PoemCrew\\nclass PoemState(BaseModel):\\n  sentence_count: int = 1\\n  poem: str = \\\"\\\"\\nclass PoemFlow(Flow[PoemState]):\\n  @start()\\n  def generate_sentence_count(self):\\n    print(\\\"Generating sentence count\\\")\\n    self.state.sentence_count = randint(1, 5)\\n  @listen(generate_sentence_count)\\n  def generate_poem(self):\\n    print(\\\"Generating poem\\\")\\n    result = PoemCrew().crew().kickoff(inputs={\\\"sentence_count\\\": self.state.sentence_count})\\n    print(\\\"Poem generated\\\", result.raw)\\n    self.state.poem = result.raw\\n  @listen(generate_poem)\\n  def save_poem(self):\\n    print(\\\"Saving poem\\\")\\n    with open(\\\"poem.txt\\\", \\\"w\\\") as f:\\n      f.write(self.state.poem)\\ndef kickoff():\\n  poem_flow = PoemFlow()\\n  poem_flow.kickoff()\\n\\ndef plot():\\n  poem_flow = PoemFlow()\\n  poem_flow.plot()\\nif __name__ == \\\"__main__\\\":\\n  kickoff()\\n\\n```\",\n        \"In this example, the `PoemFlow` class defines a flow that generates a sentence count, uses the `PoemCrew` to generate a poem, and then saves the poem to a file.\",\n        \"The flow is kicked off by calling the `kickoff()` method.\",\n        \"### Running the Flow\\n(Optional) Before running the flow, you can install the dependencies by running:\\n```bash\\ncrewai install\\n```\",\n        \"Once all of the dependencies are installed, you need to activate the virtual environment by running:\\n```bash\\nsource .venv/bin/activate\\n```\",\n        \"After activating the virtual environment, you can run the flow by executing one of the following commands:\\n```bash\\ncrewai flow kickoff\\n```\\n\\nor\\n\\n```bash\\nuv run kickoff\\n\\n```\",\n        \"The flow will execute, and you should see the output in the console.\"\n    ],\n    \"Plot Flows\": [\n        \"Visualizing your AI workflows can provide valuable insights into the structure and execution paths of your flows.\",\n        \"CrewAI offers a powerful visualization tool that allows you to generate interactive plots of your flows, making it easier to understand and optimize your AI workflows.\",\n        \"### What are Plots?\\nPlots in CrewAI are graphical representations of your AI workflows.\",\n        \"They display the various tasks, their connections, and the flow of data between them.\",\n        \"This visualization helps in understanding the sequence of operations, identifying bottlenecks, and ensuring that the workflow logic aligns with your expectations.\",\n        \"### How to Generate a Plot\\nCrewAI provides two convenient methods to generate plots of your flows:\\n#### Option 1: Using the `plot()` Method\\nIf you are working directly with a flow instance, you can generate a plot by calling the `plot()` method on your flow object.\",\n        \"This method will create an HTML file containing the interactive plot of your flow.\",\n        \"```python\\n# Assuming you have a flow instance\\nflow.plot(\\\"my_flow_plot\\\")\\n\\n```\",\n        \"This will generate a file named `my_flow_plot.html` in your current directory.\",\n        \"You can open this file in a web browser to view the interactive plot.\",\n        \"#### Option 2: Using the Command Line\\nIf you are working within a structured CrewAI project, you can generate a plot using the command line.\",\n        \"This is particularly useful for larger projects where you want to visualize the entire flow setup.\",\n        \"```bash\\ncrewai flow plot\\n```\",\n        \"This command will generate an HTML file with the plot of your flow, similar to the `plot()` method.\",\n        \"The file will be saved in your project directory, and you can open it in a web browser to explore the flow.\",\n        \"### Understanding the Plot\\nThe generated plot will display nodes representing the tasks in your flow, with directed edges indicating the flow of execution.\",\n        \"The plot is interactive, allowing you to zoom in and out, and hover over nodes to see additional details.\",\n        \"By visualizing your flows, you can gain a clearer understanding of the workflow\u2019s structure, making it easier to debug, optimize, and communicate your AI processes to others.\",\n        \"### Conclusion\\nPlotting your flows is a powerful feature of CrewAI that enhances your ability to design and manage complex AI workflows.\",\n        \"Whether you choose to use the `plot()` method or the command line, generating plots will provide you with a visual representation of your workflows, aiding in both development and presentation.\"\n    ],\n    \"Next Steps\": [\n        \"If you\u2019re interested in exploring additional examples of flows, we have a variety of recommendations in our examples repository.\",\n        \"Here are four specific flow examples, each showcasing unique use cases to help you match your current problem type to a specific example:\\n  1. **Email Auto Responder Flow** : This example demonstrates an infinite loop where a background job continually runs to automate email responses. It\u2019s a great use case for tasks that need to be performed repeatedly without manual intervention. View Example\\n  2. **Lead Score Flow** : This flow showcases adding human-in-the-loop feedback and handling different conditional branches using the router. It\u2019s an excellent example of how to incorporate dynamic decision-making and human oversight into your workflows. View Example\\n  3. **Write a Book Flow** : This example excels at chaining multiple crews together, where the output of one crew is used by another. Specifically, one crew outlines an entire book, and another crew generates chapters based on the outline. Eventually, everything is connected to produce a complete book. This flow is perfect for complex, multi-step processes that require coordination between different tasks. View Example\\n  4. **Meeting Assistant Flow** : This flow demonstrates how to broadcast one event to trigger multiple follow-up actions. For instance, after a meeting is completed, the flow can update a Trello board, send a Slack message, and save the results. It\u2019s a great example of handling multiple outcomes from a single event, making it ideal for comprehensive task management and notification systems. View Example\"\n    ]\n}\n```",
            "pydantic": "None",
            "json_dict": "None",
            "agent": "Information Extractor",
            "output_format": {
                "_value_": "raw",
                "_name_": "RAW",
                "__objclass__": "{'_generate_next_value_': <staticmethod(<function Enum._generate_next_value_ at 0x7b5e683cee80>)>, '__module__': 'crewai.tasks.output_format', '__doc__': 'Enum that represents the output format of a task.', '_new_member_': <built-in method __new__ of type object at 0x573756913420>, '_use_args_': True, '_member_names_': ['JSON', 'PYDANTIC', 'RAW'], '_member_map_': {'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>}, '_value2member_map_': {'json': <OutputFormat.JSON: 'json'>, 'pydantic': <OutputFormat.PYDANTIC: 'pydantic'>, 'raw': <OutputFormat.RAW: 'raw'>}, '_unhashable_values_': [], '_member_type_': <class 'str'>, '_value_repr_': <slot wrapper '__repr__' of 'str' objects>, '__dict__': <attribute '__dict__' of 'OutputFormat' objects>, '__weakref__': <attribute '__weakref__' of 'OutputFormat' objects>, 'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>, '__repr__': <function Enum.__repr__ at 0x7b5e683cefc0>, '__str__': <function Enum.__str__ at 0x7b5e683cf060>, '__format__': <function Enum.__format__ at 0x7b5e683cf1a0>, '__new__': <function Enum.__new__ at 0x7b5e683ced40>}",
                "_sort_order_": "2"
            }
        },
        {
            "description": "Generate concise summaries and a comprehensive study guide based on the processed information.\nCreate three outputs:\n1. A high-level overview of the main points\n2. A detailed breakdown of each section, including subsections if present\n3. A study guide that includes:\n   - Learning objectives\n   - Key concepts and definitions\n   - Review questions\n   - Practice exercises or discussion points\n   - Important terms and concepts to remember",
            "name": "None",
            "expected_output": "A dictionary with keys 'high_level_summary', 'detailed_summaries', and 'study_guide'.\nThe 'high_level_summary' value should be a string containing an overview.\nThe 'detailed_summaries' value should be a dictionary where each key is a section title and the value is a detailed summary of that section.\nThe 'study_guide' value should be a dictionary containing structured learning materials including objectives, key concepts, questions, and exercises.",
            "summary": "Generate concise summaries and a comprehensive study guide based on...",
            "raw": "```python\n{\n    \"high_level_summary\": \"CrewAI Flows is a feature designed to streamline the creation and management of AI workflows. It allows developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Flows enable the creation of structured, event-driven workflows, making it easy to connect multiple tasks, manage state, and control the flow of execution. Key features include simplified workflow creation, state management, event-driven architecture, and flexible control flow. The system supports both unstructured and structured state management, offering flexibility and type safety. Additionally, CrewAI Flows provide tools for visualizing workflows, conditional logic, and integrating multiple Crews into a single flow.\",\n    \"detailed_summaries\": {\n        \"Introduction\": \"CrewAI Flows is a powerful feature that simplifies the creation and management of AI workflows. It allows developers to chain together multiple Crews and tasks, manage state, and implement event-driven workflows. Key features include simplified workflow creation, state management, event-driven architecture, and flexible control flow.\",\n        \"Getting Started\": \"This section provides a step-by-step guide to creating a simple Flow using OpenAI to generate a random city and then a fun fact about that city. The example demonstrates how to use the `@start()` and `@listen()` decorators to define tasks and their dependencies. The Flow consists of two tasks: `generate_city` and `generate_fun_fact`, which are executed sequentially.\",\n        \"@start()\": \"The `@start()` decorator marks a method as the starting point of a Flow. Multiple start methods can be defined, and they will execute in parallel when the Flow is initiated.\",\n        \"@listen()\": \"The `@listen()` decorator marks a method as a listener for the output of another task. The listener method is triggered when the specified task emits an output, and it can access the output as an argument. The decorator can be used to listen to methods by name or directly.\",\n        \"Flow Output\": \"This section explains how to access and handle the output of a Flow. The final output is determined by the last method that completes, and it can be retrieved using the `kickoff()` method. Additionally, the state of the Flow can be accessed and updated, allowing for data sharing between tasks.\",\n        \"Flow State Management\": \"CrewAI Flows supports both unstructured and structured state management. Unstructured state management offers flexibility by allowing dynamic state attributes, while structured state management uses predefined schemas for type safety and consistency. Developers can choose the approach that best fits their application\u2019s needs.\",\n        \"Flow Control\": \"This section covers conditional logic and routing in Flows. The `or_` and `and_` functions allow for conditional execution based on the output of multiple tasks. The `@router()` decorator enables dynamic routing based on the output of a method, allowing for more complex control flow.\",\n        \"Adding Crews to Flows\": \"This section explains how to create and connect multiple Crews within a Flow. The `crewai create flow` command generates a project structure with prebuilt Crews, which can be customized. The `main.py` file is used to define the Flow and connect the Crews, allowing for complex multi-step processes.\",\n        \"Plot Flows\": \"CrewAI provides tools for visualizing Flows through interactive plots. These plots display the tasks, their connections, and the flow of data, helping developers understand and optimize their workflows. Plots can be generated using the `plot()` method or the command line.\",\n        \"Next Steps\": \"This section recommends additional examples of Flows, such as an Email Auto Responder Flow, Lead Score Flow, Write a Book Flow, and Meeting Assistant Flow. These examples showcase various use cases, including infinite loops, human-in-the-loop feedback, multi-step processes, and event broadcasting.\"\n    },\n    \"study_guide\": {\n        \"learning_objectives\": [\n            \"Understand the core features and benefits of CrewAI Flows.\",\n            \"Learn how to create and manage AI workflows using Flows.\",\n            \"Master the use of `@start()` and `@listen()` decorators to define tasks and their dependencies.\",\n            \"Explore state management options, including unstructured and structured approaches.\",\n            \"Implement conditional logic and routing in Flows using `or_`, `and_`, and `@router()`.\",\n            \"Visualize Flows using interactive plots to optimize workflow design.\",\n            \"Integrate multiple Crews into a single Flow for complex multi-step processes.\"\n        ],\n        \"key_concepts_and_definitions\": [\n            \"**Flow**: A structured, event-driven workflow that connects multiple tasks and manages state.\",\n            \"**@start()**: A decorator that marks a method as the starting point of a Flow.\",\n            \"**@listen()**: A decorator that marks a method as a listener for the output of another task.\",\n            \"**State Management**: The process of managing and sharing data between tasks in a Flow.\",\n            \"**Unstructured State Management**: A flexible approach to state management that allows dynamic state attributes.\",\n            \"**Structured State Management**: A type-safe approach to state management using predefined schemas.\",\n            \"**Conditional Logic**: Control flow mechanisms like `or_`, `and_`, and `@router()` that allow for dynamic execution based on task outputs.\",\n            \"**Plot**: A graphical representation of a Flow that visualizes tasks, connections, and data flow.\"\n        ],\n        \"review_questions\": [\n            \"What are the key features of CrewAI Flows?\",\n            \"How do you define the starting point of a Flow?\",\n            \"What is the purpose of the `@listen()` decorator?\",\n            \"What are the differences between unstructured and structured state management?\",\n            \"How can you implement conditional logic in a Flow?\",\n            \"What is the purpose of visualizing a Flow using plots?\",\n            \"How do you integrate multiple Crews into a single Flow?\"\n        ],\n        \"practice_exercises_or_discussion_points\": [\n            \"Create a simple Flow that generates a random number and then calculates its square.\",\n            \"Modify the example Flow to include a third task that logs the output of the first two tasks.\",\n            \"Implement a Flow that uses structured state management to track the number of times a task is executed.\",\n            \"Design a Flow with conditional logic that routes execution based on the output of a task.\",\n            \"Generate a plot of a Flow and analyze its structure to identify potential bottlenecks.\"\n        ],\n        \"important_terms_and_concepts_to_remember\": [\n            \"Flow\",\n            \"@start()\",\n            \"@listen()\",\n            \"State Management\",\n            \"Unstructured State\",\n            \"Structured State\",\n            \"Conditional Logic\",\n            \"Plot\"\n        ]\n    }\n}\n```",
            "pydantic": "None",
            "json_dict": "None",
            "agent": "Summary Generator and Study Guide Creator",
            "output_format": {
                "_value_": "raw",
                "_name_": "RAW",
                "__objclass__": "{'_generate_next_value_': <staticmethod(<function Enum._generate_next_value_ at 0x7b5e683cee80>)>, '__module__': 'crewai.tasks.output_format', '__doc__': 'Enum that represents the output format of a task.', '_new_member_': <built-in method __new__ of type object at 0x573756913420>, '_use_args_': True, '_member_names_': ['JSON', 'PYDANTIC', 'RAW'], '_member_map_': {'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>}, '_value2member_map_': {'json': <OutputFormat.JSON: 'json'>, 'pydantic': <OutputFormat.PYDANTIC: 'pydantic'>, 'raw': <OutputFormat.RAW: 'raw'>}, '_unhashable_values_': [], '_member_type_': <class 'str'>, '_value_repr_': <slot wrapper '__repr__' of 'str' objects>, '__dict__': <attribute '__dict__' of 'OutputFormat' objects>, '__weakref__': <attribute '__weakref__' of 'OutputFormat' objects>, 'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>, '__repr__': <function Enum.__repr__ at 0x7b5e683cefc0>, '__str__': <function Enum.__str__ at 0x7b5e683cf060>, '__format__': <function Enum.__format__ at 0x7b5e683cf1a0>, '__new__': <function Enum.__new__ at 0x7b5e683ced40>}",
                "_sort_order_": "2"
            }
        },
        {
            "description": "Refine and polish the generated summaries and study guide.\nEnsure clarity, accuracy, and pedagogical effectiveness in the final output.\nFormat the content for optimal learning experience, maintaining clear structure and organization.\nAdd bullet points, numbered lists, and callouts to enhance readability and learning.\nEnsure the study guide components are well-integrated with the summaries.",
            "name": "None",
            "expected_output": "The final, polished summaries and study guide ready for delivery, structured for effective learning and retention.",
            "summary": "Refine and polish the generated summaries and study guide.\nEnsure clarity,...",
            "raw": "---\n\n### **Polished Summary and Study Guide for CrewAI Flows**  \n\n---\n\n### **High-Level Summary**  \nCrewAI Flows is a feature designed to streamline the creation and management of AI workflows. It enables developers to combine and coordinate coding tasks and Crews efficiently, providing a robust framework for building sophisticated AI automations. Key features include:  \n- **Simplified Workflow Creation**: Easily connect multiple tasks and manage state.  \n- **Event-Driven Architecture**: Create structured, event-driven workflows.  \n- **Flexible Control Flow**: Implement conditional logic and dynamic routing.  \n- **State Management**: Supports both unstructured (dynamic) and structured (type-safe) approaches.  \n- **Visualization Tools**: Generate interactive plots to visualize workflows and optimize design.  \n- **Crew Integration**: Combine multiple Crews into a single Flow for complex multi-step processes.  \n\n---\n\n### **Detailed Summaries**  \n\n#### **1. Introduction**  \nCrewAI Flows simplifies the creation and management of AI workflows by allowing developers to chain together multiple Crews and tasks. Key features include:  \n- Simplified workflow creation.  \n- State management for data sharing between tasks.  \n- Event-driven architecture for structured workflows.  \n- Flexible control flow with conditional logic and routing.  \n\n#### **2. Getting Started**  \nThis section provides a step-by-step guide to creating a simple Flow using OpenAI to:  \n1. Generate a random city.  \n2. Generate a fun fact about that city.  \nThe example demonstrates the use of `@start()` and `@listen()` decorators to define tasks and their dependencies.  \n\n#### **3. @start()**  \nThe `@start()` decorator marks a method as the starting point of a Flow. Multiple start methods can execute in parallel when the Flow is initiated.  \n\n#### **4. @listen()**  \nThe `@listen()` decorator marks a method as a listener for the output of another task. It is triggered when the specified task emits an output, which can be accessed as an argument.  \n\n#### **5. Flow Output**  \nThe final output of a Flow is determined by the last method that completes. It can be retrieved using the `kickoff()` method. The state of the Flow can also be accessed and updated for data sharing between tasks.  \n\n#### **6. Flow State Management**  \nCrewAI Flows supports:  \n- **Unstructured State Management**: Dynamic state attributes for flexibility.  \n- **Structured State Management**: Predefined schemas for type safety and consistency.  \n\n#### **7. Flow Control**  \nConditional logic and routing are implemented using:  \n- `or_` and `and_` functions for conditional execution.  \n- `@router()` decorator for dynamic routing based on method outputs.  \n\n#### **8. Adding Crews to Flows**  \nMultiple Crews can be integrated into a single Flow using the `crewai create flow` command. The `main.py` file defines the Flow and connects the Crews for complex multi-step processes.  \n\n#### **9. Plot Flows**  \nInteractive plots visualize tasks, connections, and data flow. Plots can be generated using the `plot()` method or the command line.  \n\n#### **10. Next Steps**  \nExplore additional examples of Flows, such as:  \n- Email Auto Responder Flow.  \n- Lead Score Flow.  \n- Write a Book Flow.  \n- Meeting Assistant Flow.  \n\n---\n\n### **Study Guide**  \n\n#### **Learning Objectives**  \n1. Understand the core features and benefits of CrewAI Flows.  \n2. Learn how to create and manage AI workflows using Flows.  \n3. Master the use of `@start()` and `@listen()` decorators to define tasks and their dependencies.  \n4. Explore state management options, including unstructured and structured approaches.  \n5. Implement conditional logic and routing in Flows using `or_`, `and_`, and `@router()`.  \n6. Visualize Flows using interactive plots to optimize workflow design.  \n7. Integrate multiple Crews into a single Flow for complex multi-step processes.  \n\n#### **Key Concepts and Definitions**  \n- **Flow**: A structured, event-driven workflow that connects multiple tasks and manages state.  \n- **@start()**: A decorator that marks a method as the starting point of a Flow.  \n- **@listen()**: A decorator that marks a method as a listener for the output of another task.  \n- **State Management**: The process of managing and sharing data between tasks in a Flow.  \n- **Unstructured State Management**: A flexible approach that allows dynamic state attributes.  \n- **Structured State Management**: A type-safe approach using predefined schemas.  \n- **Conditional Logic**: Control flow mechanisms like `or_`, `and_`, and `@router()` for dynamic execution.  \n- **Plot**: A graphical representation of a Flow that visualizes tasks, connections, and data flow.  \n\n#### **Review Questions**  \n1. What are the key features of CrewAI Flows?  \n2. How do you define the starting point of a Flow?  \n3. What is the purpose of the `@listen()` decorator?  \n4. What are the differences between unstructured and structured state management?  \n5. How can you implement conditional logic in a Flow?  \n6. What is the purpose of visualizing a Flow using plots?  \n7. How do you integrate multiple Crews into a single Flow?  \n\n#### **Practice Exercises and Discussion Points**  \n1. Create a simple Flow that generates a random number and then calculates its square.  \n2. Modify the example Flow to include a third task that logs the output of the first two tasks.  \n3. Implement a Flow that uses structured state management to track the number of times a task is executed.  \n4. Design a Flow with conditional logic that routes execution based on the output of a task.  \n5. Generate a plot of a Flow and analyze its structure to identify potential bottlenecks.  \n\n#### **Important Terms and Concepts to Remember**  \n- Flow  \n- @start()  \n- @listen()  \n- State Management  \n- Unstructured State  \n- Structured State  \n- Conditional Logic  \n- Plot  \n\n---\n\nThis polished summary and study guide is structured for effective learning and retention, with clear organization, bullet points, and numbered lists to enhance readability. It integrates the summaries and study guide components seamlessly, ensuring a comprehensive learning experience.",
            "pydantic": "None",
            "json_dict": "None",
            "agent": "Summary Generator and Study Guide Creator",
            "output_format": {
                "_value_": "raw",
                "_name_": "RAW",
                "__objclass__": "{'_generate_next_value_': <staticmethod(<function Enum._generate_next_value_ at 0x7b5e683cee80>)>, '__module__': 'crewai.tasks.output_format', '__doc__': 'Enum that represents the output format of a task.', '_new_member_': <built-in method __new__ of type object at 0x573756913420>, '_use_args_': True, '_member_names_': ['JSON', 'PYDANTIC', 'RAW'], '_member_map_': {'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>}, '_value2member_map_': {'json': <OutputFormat.JSON: 'json'>, 'pydantic': <OutputFormat.PYDANTIC: 'pydantic'>, 'raw': <OutputFormat.RAW: 'raw'>}, '_unhashable_values_': [], '_member_type_': <class 'str'>, '_value_repr_': <slot wrapper '__repr__' of 'str' objects>, '__dict__': <attribute '__dict__' of 'OutputFormat' objects>, '__weakref__': <attribute '__weakref__' of 'OutputFormat' objects>, 'JSON': <OutputFormat.JSON: 'json'>, 'PYDANTIC': <OutputFormat.PYDANTIC: 'pydantic'>, 'RAW': <OutputFormat.RAW: 'raw'>, '__repr__': <function Enum.__repr__ at 0x7b5e683cefc0>, '__str__': <function Enum.__str__ at 0x7b5e683cf060>, '__format__': <function Enum.__format__ at 0x7b5e683cf1a0>, '__new__': <function Enum.__new__ at 0x7b5e683ced40>}",
                "_sort_order_": "2"
            }
        }
    ],
    "token_usage": {
        "total_tokens": "21352",
        "prompt_tokens": "12956",
        "cached_prompt_tokens": "0",
        "completion_tokens": "8396",
        "successful_requests": "3"
    }
}